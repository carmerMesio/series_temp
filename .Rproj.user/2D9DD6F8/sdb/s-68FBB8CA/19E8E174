{
    "collab_server" : "",
    "contents" : "library(tsfa)\nlibrary(nFactors)\n#library(sem)\nlibrary(vars)\nlibrary(readr)\nlibrary(foreach)\nlibrary(doParallel)\nlibrary(lubridate)\nlibrary(forecast)\n\nsuperm<-read_delim(\"Quarter Hourly Electrical Energy_01-01-2017_31-12-2017.csv\", \n                   \";\", escape_double = FALSE, trim_ws = TRUE)\n\n##cargamos los festivos en España 2017\nload(\"tabla_festivos.RData\")\n\nserie=ts(superm$`General [kWh]`,freq=96)\n\nplot(serie)\n\nparam = 310\ndif = 364-param\n\n## average by day and by variance.\nm=apply(matrix(serie,nr=96),2,mean)\nv=apply(matrix(serie,nr=96),2,var)\nplot(m,v,xlab=\"Medias anuales\",ylab=\"Varianzas anuales\",main=\"serie\")\nabline(lm(v~m),col=2,lty=3,lwd=2)\n\nboxplot(serie~floor(time(serie)))\n\n##USaremos 300 dias para predecir los otros 65.\n\n##Miramos el numero maximo de factores que puede tener la serie\n\ndatos=matrix(superm$`General [kWh]`,nrow=param,ncol=96, byrow = T)\npredicc=matrix(superm$`General [kWh]`[-c(1:(param*96))],nrow=dif,ncol=96, byrow = T)\n\n##domingos y festivos\nvaldom=ifelse(weekdays(dmy(superm$Date))==\"domingo\",1,0)\ndatdom=matrix(valdom,nrow = param,ncol = 96,byrow = T)[,1]\npreddom=matrix(valdom[-c(1:(param*96))],nrow=dif,ncol=96, byrow = T)[,1]\n\n##festivos y fiestas navidad y sem santa\nfestiusdat=matrix(news$festivo,nrow = param,ncol = 96,byrow = T)[,1]\nfestiuspred=matrix(news$festivo[-c(1:(param*96))],nrow=dif,ncol=96, byrow = T)[,1]\n  \nhwfiesdat=matrix(news$holw,nrow=param,ncol=96, byrow = T)[,1]\nhwfiespred=matrix(news$holw[-c(1:(param*96))],nrow=dif,ncol=96, byrow = T)[,1]\n\n\n#numero máximo de factores que puede tener la série.\nmaxnf=LedermannBound(datos)\n#set.seed(12dif)\n#idx=sample(1:9,365,replace=T)\n#fac=rnorm(365*96,1,0.01)\n#dades=ts(datos[idx,]*fac,freq=7)\n\n\n##Miraremos la correlación al tratarse de analisis factorial.\n#eig=eigen(var(diff(datos,lag=1)))\n##los eigen dan maximo de 6.\nzz <- eigen(cor(datos), symmetric=TRUE)[[\"values\"]] \nprint(zz)\npar(omi=c(0.1,0.1,0.1,0.1),mar=c(4.1,4.1,0.6,0.1)) \nplot(zz, ylab=\"Value\", xlab=\"Eigenvalue Number\", pch=20:20,cex=1,type=\"o\")\n\n## cogeremos los eigenvalues mayores a 1.\n#Contamos los autovalores mayores de 1 con count (metodo antiguo)\ncount=0\nfor (i in 1:length(zz)){\n  if (zz[i]>1){\n    count=count+1\n  }\n}\n## Nos devuelve 6 valores con un eigenvalue mayor a 1.\n\n\n#Calculamos el numero optimo de autovalores por el Barlett ?QUEHACE?\n#Numero optimo de factores es 5 segun Bartlett. Tiene sentido con el plot de eigenvalues.\noptnf=nBartlett(cor(datos),N = ncol(datos), alpha=0.05, cor=TRUE, details=TRUE, correction=TRUE)\nnumfatfit <- FAfitStats(datos, diff.=TRUE, maxit=30000) ##se estima mal nose si faltan iteraciones para hacerlo bien \nprint(numfatfit)\n\nnf=optnf$nFactors[1]\n##normalize TRUE o FALSE.\nfactores<-estTSF.ML(datos,nf,normalize=F,maxit=30000)\nsummary(factores)\n\n##Barplot por factores que se usan en el análisis.\n##Barplot factor loadings by day.\npar(mfrow=c(2,3))\nfor (i in 1:nf){\n  barplot(factores$loadings[,i])\n}\n\nprint(summary(1 - factores$stats$uniquenesses))\n\nfmodel<-factors(factores) #modelo dado por los factores TSFA\nplot(fmodel)\nFAfitStats(factores)\nexp=explained(factores, fmodel, names=factores$names) \n\n\n\nseriefactor <- ts(fmodel)\nvarf1 <- VAR(seriefactor,p=1, type=\"const\")\n##selection of variables by AIC.\nVARselect(seriefactor,lag.max = 10,type = \"const\")\nVARselect(seriefactor,lag.max = 7,type = \"const\",exogen = cbind(dom=datdom,s1=fourier_value[1:300,1],c1=fourier_value[1:300,2]))\nvarf1 <- MTS::VARX(seriefactor,p = 1,xt = datdom)\n\n\n#MTS::VARXpred(refVARX(varf1),hstep = 1,preddom)\n##Usar mas cores del pc.\ncl <- makeCluster(detectCores()) #demano els 8 cores del meu pc posa 8 ?\nregisterDoParallel(cl) #paralelitzo els seguents models el primer tarda i despres els altres els fa rapid.\n\n##Sin valores exogenos en los modelos VAR y AR + Estacionalidad\n\n{\n## function bucle\nj<-1\ndatos2 <- datos\ndatdom2<-datdom\nfest2 <- festiusdat\nnad2 <- hwfiesdat\np<-vector()\nfactorspred <- matrix(nrow = nf,ncol = nrow(predicc))\nresppred <- matrix(nrow = nrow(predicc),ncol = 96)\nresppredarima <- matrix(nrow = nrow(predicc),ncol = 96)\nfor(i in nrow(datos):363){\n\nfactores<-estTSF.ML(datos2,nf,normalize=F,maxit=30000)\nfmodel<-factors(factores)\nserief1ts <- ts(fmodel)\n##Mejor modelo con const.\nvarf1 <- VAR(serief1ts,p=1, type=\"const\")\n\n##Autoarima with also three covariables auxiliary. And ets with trend of 0.2\nprediccarima <- vector()\nfor(t in 1:ncol(serief1ts)){\nvararima <- auto.arima(serief1ts[,t],max.p = 7,max.q = 0,stationary = TRUE)\nvarets <- as.vector(forecast(ets(serief1ts[,t],model='AAN'),h = 1)[2]$mean)\nab<-predict(vararima)\n#prediccarima <- c(prediccarima,ab$pred)\nprediccarima <- c(prediccarima,c(.5*ab$pred+.5*varets))\n}\n\nresppredarima[j,]<-t(factores$loadings%*%prediccarima)\n\n\naa<-predict(varf1,n.ahead = 1)\n\nf1<-aa$fcst$Factor.1[,1]\nf2<-aa$fcst$Factor.2[,1]\nf3<-aa$fcst$Factor.3[,1]\nf4<-aa$fcst$Factor.4[,1]\nf5<-aa$fcst$Factor.5[,1]\n\n\nfac <- t(matrix(c(f1,f2,f3,f4,f5),nrow=length(f1),ncol=5))\nfactorspred[,j]<-fac\np<-c(p,t(factores$loadings%*%factorspred[,j]))\nresppred[j,]<-t(factores$loadings%*%factorspred[,j])\ndatos2 <- rbind(datos2,predicc[j,])\ndatdom2 <- c(datdom2,preddom[j])\nfest2 <- c(fest2,festiuspred[j])\nnad2 <- c(nad2,hwfiespred[j])\n\npar(mfrow=c(2,2))\n##plot individual\nplot(ts(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),freq=96),type=\"l\",ylab='',\n     xlab=paste0('Time | RMSE=',round(Metrics::rmse(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),\n                                                        as.vector(t(resppred[j,]))),2)),\n     lty=2,col=\"blue\",\n     ylim=c(0,max(c(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),as.vector(t(resppred[j,]))))))\ntitle(\"Individual VARX Model\")\nlines(ts(as.vector(t(resppred[j,])),freq=96))\n\n##plot colectivo\nplot(ts(as.vector(t(datos2[-c(1:nrow(datos)),])),freq=96),type=\"l\",lty=2,col=\"blue\",ylab='')\ntitle(\"VARX Collective Model\")\nlines(ts(as.vector(t(resppred)),freq=96))\n\n##plot individual arima\nplot(ts(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),freq=96),type=\"l\",ylab='',\n     xlab=paste0('Time | RMSE=',round(Metrics::rmse(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),\n                                                    as.vector(t(resppredarima[j,]))),2)),\n     lty=2,col=\"red\",ylim=c(0,max(c(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),as.vector(t(resppredarima[j,]))))))\ntitle(\"Individual Autoarima Model\")\nlines(ts(as.vector(t(resppredarima[j,])),freq=96))\n\n##plot colectivo arima\nplot(ts(as.vector(t(datos2[-c(1:nrow(datos)),])),freq=96),type=\"l\",lty=2,col=\"red\",ylab='')\ntitle(\"Autoarima Model\")\nlines(ts(as.vector(t(resppredarima)),freq=96))\n\n\nj<-j+1\n\n}\n}\n#parado paralelizado.\nstopCluster(cl)\n\n## Metrica VARX\nMetrics::rmse(as.vector(t(predicc)),as.vector(t(resppred)))\n\n#taula\nrmse_v <- numeric(54)\nmape_v <- numeric(54)\nmedian_ape_v <- numeric(54)\nrmse_vv <- numeric(54)\nmape_vv <- numeric(54)\nmedian_ape_vv <- numeric(54)\n\nfor (i in 1:dim(resppred)[1]) {\n\n  rmse_v[i] <- Metrics::rmse(predicc[i,],resppred[i,])\n  mape_v[i] <- Metrics::mape(predicc[i,],resppred[i,])\n  median_ape_v[i] <- median(Metrics::ape(predicc[i,],resppred[i,]))\n  \n  rmse_vv[i] <- Metrics::rmse(predicc[i,],resppredarima[i,])\n  mape_vv[i] <- Metrics::mape(predicc[i,],resppredarima[i,])\n  median_ape_vv[i] <- median(Metrics::ape(predicc[i,],resppredarima[i,]))\n  \n  \n}\n\noptions(digits=3)\ntaula1 <- data.frame(VAR_rmse = rmse_v, Ens_rmse = rmse_vv,\n                     VAR_mape=mape_v, Ens_mape=mape_vv,\n                     VAR_median_ape = median_ape_v, Ens_median_ape = median_ape_vv)\n\n\n\nMetrics::mape(as.vector(t(predicc)),as.vector(t(resppred)))\nmedian(ape(as.vector(t(predicc)),as.vector(t(resppred))))\n\n# metric ARIMAX\nMetrics::rmse(as.vector(t(resppredarima)),as.vector(t(resppred)))\nMetrics::mape(as.vector(t(resppredarima)),as.vector(t(resppred)))\nmedian(ape(as.vector(t(resppredarima)),as.vector(t(resppred))))\n\npar(mfrow=c(2,1))\nplot(ts(as.vector(t(datos2[-c(1:nrow(datos)),])),freq=96),type=\"p\",lty=2,col=\"blue\")\nlines(ts(as.vector(t(resppred)),freq=96))\n\nts.plot(ts(as.vector(t(resppred)),freq=96),ts(as.vector(t(datos2[-c(1:nrow(datos)),])),freq=96),lty=c(1,2),col=c(1,4))\n\nsummary(aa)\n\n#aa$model$varresult$Factor.1\n\n### Con valores exogenos.\n{\n  ## function bucle\n  j<-1\n  datos2 <- datos\n  datdom2<-datdom\n  fest2 <- festiusdat\n  nad2 <- hwfiesdat\n  p<-vector()\n  factorspred <- matrix(nrow = nf,ncol = nrow(predicc))\n  resppred <- matrix(nrow = nrow(predicc),ncol = 96)\n  resppredarima <- matrix(nrow = nrow(predicc),ncol = 96)\n  for(i in nrow(datos):363){\n    \n    factores<-estTSF.ML(datos2,nf,normalize=F,maxit=30000)\n    fmodel<-factors(factores)\n    serief1ts <- ts(fmodel)\n    ##Mejor modelo con const.\n    varf1 <- VAR(serief1ts,p=1, type=\"const\",exogen = as.matrix(cbind(dat=datdom2,fest=fest2,nad=nad2)))\n    \n    ##Autoarima with also three covariables auxiliary. And ets with trend of 0.2\n    prediccarima <- vector()\n    for(t in 1:ncol(serief1ts)){\n      vararima <- auto.arima(serief1ts[,t],max.p = 7,max.q = 0,stationary = TRUE,xreg = cbind(dat=datdom2,fest=fest2,nad=nad2))\n      varets <- as.vector(forecast(ets(serief1ts[,t],model='AAN'),h = 1)[2]$mean)\n      ab<-predict(vararima,newxreg = cbind(preddom[j],festiuspred[j],hwfiespred[j]))\n      #prediccarima <- c(prediccarima,ab$pred)\n      prediccarima <- c(prediccarima,c(.8*ab$pred+.2*varets))\n    }\n    \n    resppredarima[j,]<-t(factores$loadings%*%prediccarima)\n    \n    \n    aa<-predict(varf1,dumvar = as.matrix(cbind(preddom[j],festiuspred[j],hwfiespred[j])),n.ahead = 1)\n    \n    f1<-aa$fcst$Factor.1[,1]\n    f2<-aa$fcst$Factor.2[,1]\n    f3<-aa$fcst$Factor.3[,1]\n    f4<-aa$fcst$Factor.4[,1]\n    f5<-aa$fcst$Factor.5[,1]\n    \n    \n    fac <- t(matrix(c(f1,f2,f3,f4,f5),nrow=length(f1),ncol=5))\n    factorspred[,j]<-fac\n    p<-c(p,t(factores$loadings%*%factorspred[,j]))\n    resppred[j,]<-t(factores$loadings%*%factorspred[,j])\n    print(j)\n    datos2 <- rbind(datos2,predicc[j,])\n    datdom2 <- c(datdom2,preddom[j])\n    fest2 <- c(fest2,festiuspred[j])\n    nad2 <- c(nad2,hwfiespred[j])\n    \n    par(mfrow=c(2,2))\n    ##plot individual\n    plot(ts(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),freq=96),type=\"l\",ylab='',\n         xlab=paste0('Time | RMSE=',round(Metrics::rmse(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),\n                                                        as.vector(t(resppred[j,]))),2)),\n         lty=2,col=\"blue\",\n         ylim=c(0,max(c(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),as.vector(t(resppred[j,]))))))\n    title(\"Individual VARX Model\")\n    lines(ts(as.vector(t(resppred[j,])),freq=96))\n    \n    ##plot colectivo\n    plot(ts(as.vector(t(datos2[-c(1:nrow(datos)),])),freq=96),type=\"l\",lty=2,col=\"blue\",ylab='')\n    title(\"VARX Collective Model\")\n    lines(ts(as.vector(t(resppred)),freq=96))\n    \n    ##plot individual arima\n    plot(ts(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),freq=96),type=\"l\",ylab='',\n         lty=2,col=\"red\",ylim=c(0,max(c(as.vector(t(datos2[-c(1:(nrow(datos2)-1)),])),as.vector(t(resppredarima[j,]))))))\n    title(\"Individual Autoarima Model\")\n    lines(ts(as.vector(t(resppredarima[j,])),freq=96))\n    \n    ##plot colectivo arima\n    plot(ts(as.vector(t(datos2[-c(1:nrow(datos)),])),freq=96),type=\"l\",lty=2,col=\"red\",ylab='')\n    title(\"Autoarima Model\")\n    lines(ts(as.vector(t(resppredarima)),freq=96))\n    \n    \n    j<-j+1\n    \n  }\n}\n\n#####ToDo#########\n##Coger ahora y mirar efectos calendario. Vacaciones o fines de semana.\n##Provar random forest + ARIMA por cada variable (provar mejor ARIMAX). Mirar VarpX.\n##################\n\n##Multiplicamos cada elemento de los loadings para saber como sera el consumo del dia 181 en 96 bloques.\ndata = matrix(0,nrow = 96, ncol= length(f1))\n\nfor(i in 1:ncol(factors)){data[,i]=factores$loadings%*%factors[,i]}\n\nMetrics::rmse(datos[301:nrow(datos),],t(data))\n\n\n\n",
    "created" : 1527103767979.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3855320269",
    "id" : "19E8E174",
    "lastKnownWriteTime" : 1528217983,
    "last_content_update" : 1528217983890,
    "path" : "C:/Users/David/Desktop/forec_super_Dexma/Merca.R",
    "project_path" : "Merca.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}